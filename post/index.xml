<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jett Deng</title>
    <link>https://jett-deng.github.io/post/</link>
    <description>Recent content in Posts on Jett Deng</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 19 May 2022 12:03:55 +0800</lastBuildDate><atom:link href="https://jett-deng.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pets and Cattle</title>
      <link>https://jett-deng.github.io/post/pets-and-cattle/</link>
      <pubDate>Thu, 19 May 2022 12:03:55 +0800</pubDate>
      
      <guid>https://jett-deng.github.io/post/pets-and-cattle/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Why Promethus Pull</title>
      <link>https://jett-deng.github.io/post/why-promethus-pull/</link>
      <pubDate>Thu, 19 May 2022 12:02:44 +0800</pubDate>
      
      <guid>https://jett-deng.github.io/post/why-promethus-pull/</guid>
      <description>在数据监控领域，数据采集端获取到监控目标的数据通常有 Push 和 Pull 两种方案，其中 Push 是由数据产生端根据事件驱动主动向采集端发送数据，而 Pull 是由采集端定时拉取数据。
作为目前云原生监控中扛把子的 Prometus 采集数据采用了 Pull 模式，虽然在它官方文档的 FAQ 中给出了理由：
 可以在笔记本上监控开发时产生的变更 如果监控目标宕机了可以更容易被发现 可以通过 web 浏览器手工访问监控目标并检查其健康状况  但是这些不能说明 Pull 模式的优点，在前段时间在推特上看到了一个关于 Prometheus 采用 Pull 的讨论，经过结合官方博客的内容我对其进行了总结
Prometheus 的设计理念Prometheus 的 slogan 是「From metrics to insight」，它仅仅关心标准化地采集给定指标的当前状态，而不是导致这些指标的底层事件，所以其不是基于事件的监控系统。
例如，计量服务不会发送关于每个 HTTP 请求的消息给 Prometheus 服务器，而是在内存中简单地累加这些请求。每秒可能会发生成百上千次这种累加而不会产生任何监控流量。Prometheus 然后每隔 15 或 30 秒简单地问一下这个服务实例当前状态的累积值而已。监控结果的传输量很小，拉取模式也不会产生问题。
如果是基于事件的监控系统，需要在每一个事件「HTTP 请求、异常」发生时立即向监控服务器报告，监控服务器可以汇聚事件为指标或保存事件用于后续处理「例如ELK」。
监控目标的配置更少采用 Pull 模式，不用知道监控目标中的具体信息，也不用在监控目标不用维护指标推送的服务，这些工作都由数据采集端统一管理，而采用 Push 模式那么就需要更多的资源。
因此，采用 Pull 模式的业务开发中，只需要保证自己服务的数据能够被采集到，采集出错或异常由采集端统一处理。这样对于监控目标的应用开发来说会更简单。
Push 模式会要求更多的配置，采集端要知道监控目标，监控目标还要知道数据采集服务器，同时还需要在应用端编写错误处理、连接建立等代码，这大大增加了监控目标的负担。</description>
    </item>
    
    <item>
      <title>我的校招总结</title>
      <link>https://jett-deng.github.io/post/my-campus-offer-record/</link>
      <pubDate>Tue, 26 Apr 2022 15:30:27 +0800</pubDate>
      
      <guid>https://jett-deng.github.io/post/my-campus-offer-record/</guid>
      <description>前言时间线收获Offer</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jett-deng.github.io/post/k8s-source-code-informer-deltafifo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jett-deng.github.io/post/k8s-source-code-informer-deltafifo/</guid>
      <description>在 &amp;ldquo;Informer&amp;rdquo;开始运行时，Reflector 对象的 store 字段被设置为了 DeltaFIFO 队列对象
DeltaFIFO的结构定义的源代码如下：
type DeltaFIFO struct { // lock/cond protects access to &amp;#39;items&amp;#39; and &amp;#39;queue&amp;#39;. lock sync.RWMutex cond sync.Cond // We depend on the property that items in the set are in // the queue and vice versa, and that all Deltas in this // map have at least one Delta. items map[string]Deltas queue []string // a lot of code here } DeltaFIFO可以本
可以看到 &amp;ldquo;DeltaFIFO&amp;rdquo;可以拆分开分为两个部分来理解 [&amp;ldquo;1&amp;rdquo;]</description>
    </item>
    
  </channel>
</rss>
