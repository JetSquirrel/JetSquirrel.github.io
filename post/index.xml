<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 喷气松鼠</title>
    <link>/post/</link>
    <description>Recent content in Posts on 喷气松鼠</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 03 Jul 2022 21:18:29 +0800</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2022年7月第一周 | 步入正轨</title>
      <link>/post/2022-07-1st-week/</link>
      <pubDate>Sun, 03 Jul 2022 21:18:29 +0800</pubDate>
      
      <guid>/post/2022-07-1st-week/</guid>
      <description>这是我的七月份第一周的周报，时间范围是 2022-06-27 到 2022-07-03，主要记录了工作 / 学习 / 生活上的事情。
💻 工作 / 代码 / 计算机了解业务 &amp;amp; 接手项目在公司的工作上，这周完成新人培训在线课程的学习，并且开始了解业务相关的资料和接触项目。
开源项目没有花太多时间之前接手的 fluent-operator，这周也没有花太多时间去做。周内因为刚刚搬家还有很多事情要做，周末就在家躺尸，完全不想干活。之后还是的得调整自己时间安排，合理安排一定的时间在开源项目上。
✍️ 学习读书这周没怎么看书，只读了一本书的 Introduction 部分。
《性能之巅》（ Systems Performace ） ：这本书是衡量系统性能的百科收藏，作者是一位经验丰富的性能工程师，著有《性能之巅》、《BPF 之巅》等可观测领域的书籍 以前收集很多电子书籍，但是都存在硬盘里没有阅读，这周进行了整理，挑出了一些以后需要学习内容：
🔭 可观测性 《性能之巅》（ Systems Perfemance ） 《BPF 之巅》（ BPF Performance Tools ） Logging in Action ☁️ 云原生 Kubernets Security an Observability Networking and Kuberenets Kuberentes Operator Kubernentes Patterns Container Security 🤔 其它 《大教堂与集市》 《SRE：Google 运维解密》 对应的 PDF 已经上传到网盘，点击文末「链接」获取。</description>
    </item>
    
    <item>
      <title>2022年6月第四周</title>
      <link>/post/2022-06-4th-week/</link>
      <pubDate>Mon, 27 Jun 2022 08:18:29 +0800</pubDate>
      
      <guid>/post/2022-06-4th-week/</guid>
      <description>这是我的第一份周报，时间范围是 2022-6-20 到 2022-6-26，会记录工作 / 学习 / 生活上的事情。
💻工作 / 代码 / 计算机fluent-operator 的 Fluentd Loki 插件开发这周我又接下了开源项目 fluent-operator 的 Fluentd Loki 插件开发 issue，本以为有了上次提交 OpenSearch 插件经验会完成的更加顺畅，今天上手后才发现还是有很多问题需要进行解决，这对我来说会是一个很大的挑战。
Golang 代码规范周五学习了 Golang 的代码规范，发现平时自己在写 Golang 的时候有些地方不符合规范，以后得多多留意。另外，我发现关注的开源项目 fluent-operator 和 siyuan-note 中，有些代码不符合 Golang 规范，以后可以在这些地方水一水 PR。
✍️学习读书这周读了三本书：
Google SRE 运维解密：讲解 SRE 这个工作岗位的由来以及在 Google 中的实践经验，目前看到了第六章 「分布式系统的监控」 教堂与集市：讲解开源文化，目前看到了第二章「教堂与集市」 Build Your Second Brain：由于是全英文，目前只看了 Introduction，但是通过相关解读这本书的中文博客和视频学习到了「P.A.R.A」知识管理方法 我的阅读软件采用了「思源笔记」，双链标注 PDF 的方式是真的好用，非常适合整理读书笔记 P.A.R.AP.A.R.A 是 Tiago Forte 发明的项目管理方法，其中
项目（Project）：具有明确目标以及时间范围，是最小执行单位 领域（Area）：长期需要关注的领域（带责任） 资源（Resource）：感兴趣的事情（非责任） 归档（Archive）：沉寂的内容，但也许对未来有用 笔记工具采用的是「思源笔记」，目前已经将以前的笔记转化为 P.</description>
    </item>
    
    <item>
      <title>Informer Deltafifo 源码解读</title>
      <link>/post/k8s-source-code-informer-deltafifo/</link>
      <pubDate>Thu, 19 May 2022 22:16:06 +0800</pubDate>
      
      <guid>/post/k8s-source-code-informer-deltafifo/</guid>
      <description>在 Informer开始运行时，Reflector 对象的 store 字段被设置为了 DeltaFIFO 队列对象
DeltaFIFO的结构定义的源代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 type DeltaFIFO struct { // lock/cond protects access to &amp;#39;items&amp;#39; and &amp;#39;queue&amp;#39;. lock sync.RWMutex cond sync.Cond // We depend on the property that items in the set are in // the queue and vice versa, and that all Deltas in this // map have at least one Delta. items map[string]Deltas queue []string // a lot of code here } DeltaFIFO可以本</description>
    </item>
    
    <item>
      <title>为什么 Promethus 采用了 Pull 模式？</title>
      <link>/post/why-promethus-using-pull/</link>
      <pubDate>Thu, 19 May 2022 12:02:44 +0800</pubDate>
      
      <guid>/post/why-promethus-using-pull/</guid>
      <description>在计算机系统的监控中，采集指标通常有两种方式：
Push Pull Push 是数据产生端由事件驱动，主动向采集端发送指标数据，与之相对应的 Pull 是由采集端定时拉取数据。 作为目前云原生监控中扛把子的 Prometus 采集数据采用了 Pull 模式，虽然在官方文档 FAQ 中给出了理由：
可以在笔记本上监控开发时产生的变更 如果监控目标宕机了可以更容易被发现 可以通过 web 浏览器手工访问监控目标并检查其健康状况 但是这些不能说明 Pull 模式的优点，在前段时间在推特上看到了一个关于 Prometheus 采用 Pull 模式的Twitter讨论，为此本文
Prometheus 的设计理念Prometheus 的 slogan 是「metrics to insight」，意思是它仅仅关心标准化地采集给定指标的当前状态，而不是导致这些指标的底层事件，所以其不是基于事件的监控系统。
例如，计量服务不会发送关于每个 HTTP 请求的消息给 Prometheus 服务器，而是在内存中简单地累加这些请求。每秒可能会发生成百上千次这种累加而不会产生任何监控流量。Prometheus 然后每隔 15 或 30 秒简单地问一下这个服务实例当前状态的累积值而已。监控结果的传输量很小，拉取模式也不会产生问题。
如果是基于事件的监控系统，需要在每一个事件「HTTP 请求、异常」发生时立即向监控服务器报告，监控服务器可以汇聚事件为指标或保存事件用于后续处理，例如ELK。
监控目标的配置更少采用 Pull 模式，不用知道监控目标中的具体信息，也不用在监控目标不用维护指标推送的服务，这些工作都由数据采集端统一管理，而采用 Push 模式那么就需要更多的资源。
因此，采用 Pull 模式的业务开发中，只需要保证自己服务的数据能够被采集到，采集出错或异常由采集端统一处理。这样对于监控目标的应用开发来说会更简单。
Push 模式会要求更多的配置，采集端要知道监控目标，监控目标还要知道数据采集服务器，同时还需要在应用端编写错误处理、连接建立等代码，这大大增加了监控目标的负担。
掌握主动权无论哪种模式，如果发送给时序数据库的数据量超过它的处理能力都会导致服务器宕机。但是存在的区别是， Push 模式通常会由业务开发人员在业务逻辑中编写，由于其水平参差不齐，代码编写存在着问题将会造成对监控服务造成巨大的负载；而监控团队通常就一个 Team，通常是对监控系统的熟悉程度更高，代码质量相对可控，因此 Pull 模式能够将这一部分风险降低。
更好控制数据粒度pull 模式能够有更好的控制数据的粒度，不管是画图，还是做算法分析，数据预处理的过程都会比较简单
Pull 模式的缺点当然采用 Pull 也会带来一些问题：</description>
    </item>
    
  </channel>
</rss>
